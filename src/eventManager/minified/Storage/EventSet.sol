pragma solidity^0.6.7;import"../Event.sol"as EventContract;contract EventSet{mapping(EventContract.Event=>uint)index;mapping(address=>EventContract.Event[])user_mapping;EventContract.Event[]event_store;constructor()public {address payable zrx_event_address=address(0);string memory zrx_event_name="0xEvent";string memory zrx_event_location="0xLocation";uint256 zrx_five_min_time=5*60*1000;uint256 zrx_event_time_start=now+zrx_five_min_time;uint256 zrx_event_time_end=zrx_event_time_start+zrx_five_min_time;addToArray(new EventContract.Event(zrx_event_address,zrx_event_name,zrx_event_location,zrx_event_time_start,zrx_event_time_end));} function addToArray(EventContract.Event event_element)public {require(address(event_element)!=address(0),"Invalid Event");require(!inArray(event_element),"Event already in Array");index[event_element]=event_store.length;event_store.push(event_element);address event_initiator=event_element.getInitiator();user_mapping[event_initiator].push(event_element);} function inArray(EventContract.Event event_address)public view returns(bool in_array) {return(index[event_address]>0);} function getPosition(EventContract.Event event_address)public view returns(uint address_position) {if(address(event_address)==address(0))return 0;return index[event_address];} function getByPosition(uint pos)public view returns(EventContract.Event event_element) {require(pos>0,"this index is not valid");require(pos<event_store.length,"out of bounds");return event_store[pos];} function getElementCount()public view returns(uint element_count) {return event_store.length-1;} function getEventArray()public view returns(EventContract.Event[]memory event_array) {event_array=new EventContract.Event[](event_store.length-1);for(uint i=0;i<event_store.length-1;i++){event_array[i]=event_store[i+1];} return event_array;} function getUserEventArray(address payable event_initiator,bool check_participant)public view returns(EventContract.Event[]memory event_array) {if(!check_participant){return user_mapping[event_initiator];}else{uint user_event_count=0;for(uint i=0;i<event_store.length;i++){if(i>0){EventContract.Event temporary_event=event_store[i];if(temporary_event.isParticipant(event_initiator)){user_event_count++;}}} event_array=new EventContract.Event[](user_event_count);uint k=0;for(uint j=0;j<event_store.length-1;j++){EventContract.Event temporaryEvent=event_store[j+1];if(temporaryEvent.isParticipant(event_initiator)){event_array[k]=temporaryEvent;k++;}} return event_array;}} function removeFromArray(EventContract.Event event_address)public {require(inArray(event_address),"Event not in Array");uint pos=getPosition(event_address);for(uint i=pos;i<event_store.length-1;i++){index[event_store[i+1]]=index[event_store[i]];event_store[i]=event_store[i+1];} address event_initiator=event_address.getInitiator();delete index[event_address];event_store.pop();uint event_pos=0;for(uint j=0;j<user_mapping[event_initiator].length;j++){if(user_mapping[event_initiator][j]==event_address){event_pos=j;}} for(uint l=event_pos;l<user_mapping[event_initiator].length-1;l++){user_mapping[event_initiator][l]=user_mapping[event_initiator][l+1];} user_mapping[event_initiator].pop();}}

