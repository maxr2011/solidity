pragma solidity^0.6.7;import"eventManager/Event.sol"as EventContract;contract EventSet{mapping(address=>uint)index;mapping(address=>address[])user_mapping;EventContract.Event[]event_store;constructor()public {index[address(0)]=0;event_store.push(EventContract.Event(0));} function addToArray(EventContract.Event event_element)public {address event_address=address(event_element);require(event_address!=address(0),"Invalid Event");require(!inArray(event_address),"Event already in Array");index[event_address]=event_store.length;event_store.push(event_element);address event_initiator=event_element.getInitiator();user_mapping[event_initiator].push(event_address);} function inArray(address event_address)public view returns(bool in_array) {return(index[event_address]>0);} function getPosition(address event_address)public view returns(uint address_position) {if(event_address==address(0))return 0;return index[event_address];} function getByPosition(uint pos)public view returns(EventContract.Event event_element) {require(pos>0,"this index is not valid");require(pos<event_store.length,"out of bounds");return event_store[pos];} function getElementCount()public view returns(uint element_count) {return event_store.length-1;} function getEventArray()public view returns(EventContract.Event[]memory event_array) {event_array=new EventContract.Event[](event_store.length-1);for(uint i=0;i<event_store.length-1;i++){event_array[i]=event_store[i+1];} return event_array;} function getUserEventArray(address payable event_initiator,bool check_participant)public view returns(address[]memory event_array) {if(!check_participant){return user_mapping[event_initiator];}else{uint user_event_count=0;for(uint i=1;i<event_store.length;i++){if(event_store[i].isParticipant(event_initiator)){user_event_count++;}} event_array=new address[](user_event_count);uint k=0;for(uint j=0;j<event_store.length-1;j++){EventContract.Event temporaryEvent=event_store[j+1];if(temporaryEvent.isParticipant(event_initiator)){event_array[k]=address(temporaryEvent);k++;}} return event_array;}} function removeFromArray(EventContract.Event event_element)public {address event_address=address(event_element);require(inArray(event_address),"Event not in Array");uint pos=getPosition(event_address);for(uint i=pos;i<event_store.length-1;i++){index[address(event_store[i+1])]=index[address(event_store[i])];event_store[i]=event_store[i+1];} address event_initiator=event_element.getInitiator();delete index[event_address];event_store.pop();uint event_pos=0;for(uint j=0;j<user_mapping[event_initiator].length;j++){if(user_mapping[event_initiator][j]==event_address){event_pos=j;}} for(uint l=event_pos;l<user_mapping[event_initiator].length-1;l++){user_mapping[event_initiator][l]=user_mapping[event_initiator][l+1];} user_mapping[event_initiator].pop();}}
