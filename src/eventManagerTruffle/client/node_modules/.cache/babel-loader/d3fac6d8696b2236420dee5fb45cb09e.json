{"ast":null,"code":"var f = require('./formatters');\n\nvar SolidityParam = require('./param');\n/**\r\n * SolidityType prototype is used to encode/decode solidity params of certain type\r\n */\n\n\nvar SolidityType = function (config) {\n  this._inputFormatter = config.inputFormatter;\n  this._outputFormatter = config.outputFormatter;\n};\n/**\r\n * Should be used to determine if this SolidityType do match given name\r\n *\r\n * @method isType\r\n * @param {String} name\r\n * @return {Bool} true if type match this SolidityType, otherwise false\r\n */\n\n\nSolidityType.prototype.isType = function (name) {\n  throw \"This method should be overwritten for type \" + name;\n};\n/**\r\n * Should be used to determine what is the length of static part in given type\r\n *\r\n * @method staticPartLength\r\n * @param {String} name\r\n * @return {Number} length of static part in bytes\r\n */\n\n\nSolidityType.prototype.staticPartLength = function (name) {\n  // If name isn't an array then treat it like a single element array.\n  return (this.nestedTypes(name) || ['[1]']).map(function (type) {\n    // the length of the nested array\n    return parseInt(type.slice(1, -1), 10) || 1;\n  }).reduce(function (previous, current) {\n    return previous * current; // all basic types are 32 bytes long\n  }, 32);\n};\n/**\r\n * Should be used to determine if type is dynamic array\r\n * eg:\r\n * \"type[]\" => true\r\n * \"type[4]\" => false\r\n *\r\n * @method isDynamicArray\r\n * @param {String} name\r\n * @return {Bool} true if the type is dynamic array\r\n */\n\n\nSolidityType.prototype.isDynamicArray = function (name) {\n  var nestedTypes = this.nestedTypes(name);\n  return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);\n};\n/**\r\n * Should be used to determine if type is static array\r\n * eg:\r\n * \"type[]\" => false\r\n * \"type[4]\" => true\r\n *\r\n * @method isStaticArray\r\n * @param {String} name\r\n * @return {Bool} true if the type is static array\r\n */\n\n\nSolidityType.prototype.isStaticArray = function (name) {\n  var nestedTypes = this.nestedTypes(name);\n  return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);\n};\n/**\r\n * Should return length of static array\r\n * eg.\r\n * \"int[32]\" => 32\r\n * \"int256[14]\" => 14\r\n * \"int[2][3]\" => 3\r\n * \"int\" => 1\r\n * \"int[1]\" => 1\r\n * \"int[]\" => 1\r\n *\r\n * @method staticArrayLength\r\n * @param {String} name\r\n * @return {Number} static array length\r\n */\n\n\nSolidityType.prototype.staticArrayLength = function (name) {\n  var nestedTypes = this.nestedTypes(name);\n\n  if (nestedTypes) {\n    return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);\n  }\n\n  return 1;\n};\n/**\r\n * Should return nested type\r\n * eg.\r\n * \"int[32]\" => \"int\"\r\n * \"int256[14]\" => \"int256\"\r\n * \"int[2][3]\" => \"int[2]\"\r\n * \"int\" => \"int\"\r\n * \"int[]\" => \"int\"\r\n *\r\n * @method nestedName\r\n * @param {String} name\r\n * @return {String} nested name\r\n */\n\n\nSolidityType.prototype.nestedName = function (name) {\n  // remove last [] in name\n  var nestedTypes = this.nestedTypes(name);\n\n  if (!nestedTypes) {\n    return name;\n  }\n\n  return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);\n};\n/**\r\n * Should return true if type has dynamic size by default\r\n * such types are \"string\", \"bytes\"\r\n *\r\n * @method isDynamicType\r\n * @param {String} name\r\n * @return {Bool} true if is dynamic, otherwise false\r\n */\n\n\nSolidityType.prototype.isDynamicType = function () {\n  return false;\n};\n/**\r\n * Should return array of nested types\r\n * eg.\r\n * \"int[2][3][]\" => [\"[2]\", \"[3]\", \"[]\"]\r\n * \"int[] => [\"[]\"]\r\n * \"int\" => null\r\n *\r\n * @method nestedTypes\r\n * @param {String} name\r\n * @return {Array} array of nested types\r\n */\n\n\nSolidityType.prototype.nestedTypes = function (name) {\n  // return list of strings eg. \"[]\", \"[3]\", \"[]\", \"[2]\"\n  return name.match(/(\\[[0-9]*\\])/g);\n};\n/**\r\n * Should be used to encode the value\r\n *\r\n * @method encode\r\n * @param {Object} value\r\n * @param {String} name\r\n * @return {String} encoded value\r\n */\n\n\nSolidityType.prototype.encode = function (value, name) {\n  var self = this;\n\n  if (this.isDynamicArray(name)) {\n    return function () {\n      var length = value.length; // in int\n\n      var nestedName = self.nestedName(name);\n      var result = [];\n      result.push(f.formatInputInt(length).encode());\n      value.forEach(function (v) {\n        result.push(self.encode(v, nestedName));\n      });\n      return result;\n    }();\n  } else if (this.isStaticArray(name)) {\n    return function () {\n      var length = self.staticArrayLength(name); // in int\n\n      var nestedName = self.nestedName(name);\n      var result = [];\n\n      for (var i = 0; i < length; i++) {\n        result.push(self.encode(value[i], nestedName));\n      }\n\n      return result;\n    }();\n  }\n\n  return this._inputFormatter(value, name).encode();\n};\n/**\r\n * Should be used to decode value from bytes\r\n *\r\n * @method decode\r\n * @param {String} bytes\r\n * @param {Number} offset in bytes\r\n * @param {String} name type name\r\n * @returns {Object} decoded value\r\n */\n\n\nSolidityType.prototype.decode = function (bytes, offset, name) {\n  var self = this;\n\n  if (this.isDynamicArray(name)) {\n    return function () {\n      var arrayOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes\n\n      var length = parseInt('0x' + bytes.substr(arrayOffset * 2, 64)); // in int\n\n      var arrayStart = arrayOffset + 32; // array starts after length; // in bytes\n\n      var nestedName = self.nestedName(name);\n      var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes\n\n      var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;\n      var result = [];\n\n      for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {\n        result.push(self.decode(bytes, arrayStart + i, nestedName));\n      }\n\n      return result;\n    }();\n  } else if (this.isStaticArray(name)) {\n    return function () {\n      var length = self.staticArrayLength(name); // in int\n\n      var arrayStart = offset; // in bytes\n\n      var nestedName = self.nestedName(name);\n      var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes\n\n      var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;\n      var result = [];\n\n      for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {\n        result.push(self.decode(bytes, arrayStart + i, nestedName));\n      }\n\n      return result;\n    }();\n  } else if (this.isDynamicType(name)) {\n    return function () {\n      var dynamicOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes\n\n      var length = parseInt('0x' + bytes.substr(dynamicOffset * 2, 64)); // in bytes\n\n      var roundedLength = Math.floor((length + 31) / 32); // in int\n\n      var param = new SolidityParam(bytes.substr(dynamicOffset * 2, (1 + roundedLength) * 64), 0, bytes);\n      return self._outputFormatter(param, name);\n    }();\n  }\n\n  var length = this.staticPartLength(name);\n  var param = new SolidityParam(bytes.substr(offset * 2, length * 2), undefined, bytes);\n  return this._outputFormatter(param, name);\n};\n\nmodule.exports = SolidityType;","map":{"version":3,"sources":["C:/Users/Blockchain FWPM/Desktop/N/solidity/src/eventManagerTruffle/client/node_modules/drizzle/node_modules/web3-eth-abi/src/type.js"],"names":["f","require","SolidityParam","SolidityType","config","_inputFormatter","inputFormatter","_outputFormatter","outputFormatter","prototype","isType","name","staticPartLength","nestedTypes","map","type","parseInt","slice","reduce","previous","current","isDynamicArray","length","match","isStaticArray","staticArrayLength","nestedName","substr","isDynamicType","encode","value","self","result","push","formatInputInt","forEach","v","i","decode","bytes","offset","arrayOffset","arrayStart","nestedStaticPartLength","roundedNestedStaticPartLength","Math","floor","dynamicOffset","roundedLength","param","undefined","module","exports"],"mappings":"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","sourcesContent":["var f = require('./formatters');\r\nvar SolidityParam = require('./param');\r\n\r\n/**\r\n * SolidityType prototype is used to encode/decode solidity params of certain type\r\n */\r\nvar SolidityType = function (config) {\r\n    this._inputFormatter = config.inputFormatter;\r\n    this._outputFormatter = config.outputFormatter;\r\n};\r\n\r\n/**\r\n * Should be used to determine if this SolidityType do match given name\r\n *\r\n * @method isType\r\n * @param {String} name\r\n * @return {Bool} true if type match this SolidityType, otherwise false\r\n */\r\nSolidityType.prototype.isType = function (name) {\r\n    throw \"This method should be overwritten for type \" + name;\r\n};\r\n\r\n/**\r\n * Should be used to determine what is the length of static part in given type\r\n *\r\n * @method staticPartLength\r\n * @param {String} name\r\n * @return {Number} length of static part in bytes\r\n */\r\nSolidityType.prototype.staticPartLength = function (name) {\r\n    // If name isn't an array then treat it like a single element array.\r\n    return (this.nestedTypes(name) || ['[1]'])\r\n        .map(function (type) {\r\n            // the length of the nested array\r\n            return parseInt(type.slice(1, -1), 10) || 1;\r\n        })\r\n        .reduce(function (previous, current) {\r\n            return previous * current;\r\n        // all basic types are 32 bytes long\r\n        }, 32);\r\n};\r\n\r\n/**\r\n * Should be used to determine if type is dynamic array\r\n * eg:\r\n * \"type[]\" => true\r\n * \"type[4]\" => false\r\n *\r\n * @method isDynamicArray\r\n * @param {String} name\r\n * @return {Bool} true if the type is dynamic array\r\n */\r\nSolidityType.prototype.isDynamicArray = function (name) {\r\n    var nestedTypes = this.nestedTypes(name);\r\n    return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);\r\n};\r\n\r\n/**\r\n * Should be used to determine if type is static array\r\n * eg:\r\n * \"type[]\" => false\r\n * \"type[4]\" => true\r\n *\r\n * @method isStaticArray\r\n * @param {String} name\r\n * @return {Bool} true if the type is static array\r\n */\r\nSolidityType.prototype.isStaticArray = function (name) {\r\n    var nestedTypes = this.nestedTypes(name);\r\n    return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);\r\n};\r\n\r\n/**\r\n * Should return length of static array\r\n * eg.\r\n * \"int[32]\" => 32\r\n * \"int256[14]\" => 14\r\n * \"int[2][3]\" => 3\r\n * \"int\" => 1\r\n * \"int[1]\" => 1\r\n * \"int[]\" => 1\r\n *\r\n * @method staticArrayLength\r\n * @param {String} name\r\n * @return {Number} static array length\r\n */\r\nSolidityType.prototype.staticArrayLength = function (name) {\r\n    var nestedTypes = this.nestedTypes(name);\r\n    if (nestedTypes) {\r\n       return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);\r\n    }\r\n    return 1;\r\n};\r\n\r\n/**\r\n * Should return nested type\r\n * eg.\r\n * \"int[32]\" => \"int\"\r\n * \"int256[14]\" => \"int256\"\r\n * \"int[2][3]\" => \"int[2]\"\r\n * \"int\" => \"int\"\r\n * \"int[]\" => \"int\"\r\n *\r\n * @method nestedName\r\n * @param {String} name\r\n * @return {String} nested name\r\n */\r\nSolidityType.prototype.nestedName = function (name) {\r\n    // remove last [] in name\r\n    var nestedTypes = this.nestedTypes(name);\r\n    if (!nestedTypes) {\r\n        return name;\r\n    }\r\n\r\n    return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);\r\n};\r\n\r\n/**\r\n * Should return true if type has dynamic size by default\r\n * such types are \"string\", \"bytes\"\r\n *\r\n * @method isDynamicType\r\n * @param {String} name\r\n * @return {Bool} true if is dynamic, otherwise false\r\n */\r\nSolidityType.prototype.isDynamicType = function () {\r\n    return false;\r\n};\r\n\r\n/**\r\n * Should return array of nested types\r\n * eg.\r\n * \"int[2][3][]\" => [\"[2]\", \"[3]\", \"[]\"]\r\n * \"int[] => [\"[]\"]\r\n * \"int\" => null\r\n *\r\n * @method nestedTypes\r\n * @param {String} name\r\n * @return {Array} array of nested types\r\n */\r\nSolidityType.prototype.nestedTypes = function (name) {\r\n    // return list of strings eg. \"[]\", \"[3]\", \"[]\", \"[2]\"\r\n    return name.match(/(\\[[0-9]*\\])/g);\r\n};\r\n\r\n/**\r\n * Should be used to encode the value\r\n *\r\n * @method encode\r\n * @param {Object} value\r\n * @param {String} name\r\n * @return {String} encoded value\r\n */\r\nSolidityType.prototype.encode = function (value, name) {\r\n    var self = this;\r\n    if (this.isDynamicArray(name)) {\r\n\r\n        return (function () {\r\n            var length = value.length;                          // in int\r\n            var nestedName = self.nestedName(name);\r\n\r\n            var result = [];\r\n            result.push(f.formatInputInt(length).encode());\r\n\r\n            value.forEach(function (v) {\r\n                result.push(self.encode(v, nestedName));\r\n            });\r\n\r\n            return result;\r\n        })();\r\n\r\n    } else if (this.isStaticArray(name)) {\r\n\r\n        return (function () {\r\n            var length = self.staticArrayLength(name);          // in int\r\n            var nestedName = self.nestedName(name);\r\n\r\n            var result = [];\r\n            for (var i = 0; i < length; i++) {\r\n                result.push(self.encode(value[i], nestedName));\r\n            }\r\n\r\n            return result;\r\n        })();\r\n\r\n    }\r\n\r\n    return this._inputFormatter(value, name).encode();\r\n};\r\n\r\n/**\r\n * Should be used to decode value from bytes\r\n *\r\n * @method decode\r\n * @param {String} bytes\r\n * @param {Number} offset in bytes\r\n * @param {String} name type name\r\n * @returns {Object} decoded value\r\n */\r\nSolidityType.prototype.decode = function (bytes, offset, name) {\r\n    var self = this;\r\n\r\n    if (this.isDynamicArray(name)) {\r\n\r\n        return (function () {\r\n            var arrayOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes\r\n            var length = parseInt('0x' + bytes.substr(arrayOffset * 2, 64)); // in int\r\n            var arrayStart = arrayOffset + 32; // array starts after length; // in bytes\r\n\r\n            var nestedName = self.nestedName(name);\r\n            var nestedStaticPartLength = self.staticPartLength(nestedName);  // in bytes\r\n            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;\r\n            var result = [];\r\n\r\n            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {\r\n                result.push(self.decode(bytes, arrayStart + i, nestedName));\r\n            }\r\n\r\n            return result;\r\n        })();\r\n\r\n    } else if (this.isStaticArray(name)) {\r\n\r\n        return (function () {\r\n            var length = self.staticArrayLength(name);                      // in int\r\n            var arrayStart = offset;                                        // in bytes\r\n\r\n            var nestedName = self.nestedName(name);\r\n            var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes\r\n            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;\r\n            var result = [];\r\n\r\n            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {\r\n                result.push(self.decode(bytes, arrayStart + i, nestedName));\r\n            }\r\n\r\n            return result;\r\n        })();\r\n    } else if (this.isDynamicType(name)) {\r\n\r\n        return (function () {\r\n            var dynamicOffset = parseInt('0x' + bytes.substr(offset * 2, 64));      // in bytes\r\n            var length = parseInt('0x' + bytes.substr(dynamicOffset * 2, 64));      // in bytes\r\n            var roundedLength = Math.floor((length + 31) / 32);                     // in int\r\n            var param = new SolidityParam(bytes.substr(dynamicOffset * 2, ( 1 + roundedLength) * 64), 0, bytes);\r\n            return self._outputFormatter(param, name);\r\n        })();\r\n    }\r\n\r\n    var length = this.staticPartLength(name);\r\n    var param = new SolidityParam(bytes.substr(offset * 2, length * 2), undefined, bytes);\r\n    return this._outputFormatter(param, name);\r\n};\r\n\r\nmodule.exports = SolidityType;\r\n"]},"metadata":{},"sourceType":"script"}